/**
 * @file CityReport.h
 *
 * @author Mannan Dhillon
 *
 * The city report is generated by the members of the city.
 * It is a collection of objects of type MemberReport.
 */

#pragma once

#include <memory>
#include <vector>
#include <random>

class City;
class MemberReport;

/**
 * The city report is generated by the members of the city.
 * It is a collection of objects of type MemberReport.
*/
class CityReport
{


private:
    /// The city this report is for
    City* mCity;

    /// Random number generator
    std::mt19937 mRandom;

protected:
    /// Contents container location for a report
    class ReportHolder {
    public:
        /// The actual report
        std::shared_ptr<MemberReport> mReport;

        /// The next container or -1 for none
        int mNextContainer = -1;

        /// The next location in that container
        int mNextLocation = 0;


    };

    /// The number of containers to use
    static const int NumContainers = 3;

    /// The containers
    std::vector<std::shared_ptr<ReportHolder>> mContainers[NumContainers];

    /// The first container, initially -1 for no container
    int mFirstContainer = -1;

    /// The first location in the first container
    int mFirstLocation = 0;

    /// The container for the last record
    int mLastContainer = -1;

    /// The location in the container for the last record
    int mLastLocation = 0;

public:
    explicit CityReport(City* city);

    void Add(std::shared_ptr<MemberReport> report);
    /**
     * Iterator class
     */
    class Iter{
    private:
        /// collection of the city report
        CityReport* mCollection;
        /// postion variable
        int mPos;
        /// location variable
        int mTrack;
    public:
        /**
         * constructor
         * @param collection, collections,pos
         *
         */
        Iter(CityReport* collection, int collections, int pos):
                mCollection(collection), mPos(pos), mTrack(collections){};
        /**
         * Test for end of the iterator
         * @param other
         * @return boolean
         */
        bool operator != (const Iter &other) const
        {
            return mPos != other.mPos or mTrack != other.mTrack;

        }
        /**
        * get value at current postion
         * @return mReport
        */
        std::shared_ptr<MemberReport> operator *() const
        { auto container = mCollection->mContainers[mTrack][mPos];
            return container->mReport;}
        /**
         * Increment the iterator
         * @return pointer to this
         */
        const Iter& operator++()
        {
            auto container = mCollection->mContainers[mTrack][mPos];
            mTrack = container->mNextContainer;
            mPos = container->mNextLocation;

            return *this;
        }

    };
    /**
* Get an iterator for the beginning of the collection
* @return Iter object at position 0
*/
    Iter begin() { return Iter(this, mFirstContainer, mFirstLocation); }
    /**
     * Get an iterator for the end of the collection
     * @return Iter object at position past the end
     */
    Iter end() { return Iter(this,-1 , 0); }
};

